options
{
	JDK_VERSION = "1.7";
	static = false;
}

PARSER_BEGIN(RPLanguage)
import java.io.*;
import java.util.*;
import my_package.*;

public class RPLanguage
{
  	private STable table=new STable();
  	
	public static void main(String args []) throws ParseException, FileNotFoundException
  	{
    	RPLanguage parser = new RPLanguage(new FileInputStream(new File("input/regole2.txt")));

		//parsing e costruzione dell'albero sintattico
		Node root=parser.start();
		Btree tree=new Btree(root);
		Visitor visitor=new Visitor();

//		//visita preorder dell'albero sinattico//		System.out.println("\nPRE-ORDER VISIT:\n");//		ArrayList <Node> nodeList = visitor.preorderVisit(tree);//		Iterator<Node> itr1=nodeList.iterator();//		while(itr1.hasNext())//    		System.out.println((itr1.next()).getVal()+"\n");////		//visita postorder dell'albero sintattico//		System.out.println("\nPOST-ORDER VISIT:\n");//		nodeList = visitor.postorderVisit(tree);//		itr1=nodeList.iterator();//		while(itr1.hasNext())//			System.out.println((itr1.next()).getVal()+"\n");

		//generazione del codice per javaCC
		System.out.println("\n\nJavaCC-code:\n");
		GenJavaCCCode generator = new GenJavaCCCode();
		ArrayList<String> code=generator.genCode(tree);
		Iterator<String> itr2=code.iterator();
		while(itr2.hasNext())
			System.out.println(itr2.next());
  	}	
}
PARSER_END(RPLanguage)

TOKEN_MGR_DECLS:
{
}

SKIP:{
  "\r"
| "\n"
| "\t"
| " "
| <"//"(~["\n","\r"])*("\n"|"\r") >								/*commento su singola linea*/
}

/*LO SKIP DEL COMMENTO MULTILINEA AVVIENE MEDIANE PASSAGGIO DI STATO LESSICALE*/
SKIP:
{
  < "/*" > : IN_COMMENTO
}
<IN_COMMENTO>
SKIP:
{
  < "*/" >: DEFAULT
| < ~[] > 
}
/*----------------------------------------------------------------------------ESPRESSIONI REGOLARI*/

TOKEN:
{
  < #LETTERA: ["A"-"Z","a"-"z"] > 								/*lettera*/

| < #CIFRA: ["0"-"9"] >			  								/*cifra*/

| < PARAPERTA_T: "(" >											/*parentesi tonda aperta per il numero di simboli di lookahead*/

| < PARCHIUSA_T: ")" >											/*parentesi tonda chiusa per il numero di simboli di lookahead*/

| < PARAPERTA_Q: "[" >											/*opzionalità*/

| < PARCHIUSA_Q: "]" >											/*opzionalità*/

| < PV: ";" >					 								/*punto e virgola*/
	
| < EPS: "eps" >				 								/*epslon*/

| < PIPE: "|">					 								/*pipe*/

| < PUO_ESSERE: "::=" >			 								/*puo essere*/

| < NUM_LOOKAHEAD: (<CIFRA>)+ >									/*numero di simboli di lookahead*/

| < OP_LOOKAHEAD: "LOOKAHEAD"|"lookahead" >						/*operatore di loockahead*/

| < NON_TERM: "<"(~[											/*simbolo non terminali*/
					"\n","\r","\t","<",">","|"," ",":","=",				
					"[","]","/", ";","(",")","*","+","~",
					"\"","'","?","#",",","-","{","}"
				 ])+
			  ">" >														

| < TERM: (~[													/*simbolo terminali*/
			"\n","\r","\t","<",">","|"," ",":","=",
			"[","]","/", ";","(",")","*","+","~",
			"\"","'","?","#",",","-","{","}"
		  ])+>

//| < COMMENTO_M: "/*"(~[])*"*/" >										/*commento multilinea*/
//| < OPZ : "["((<NON_TERM>|<TERM>)(" ")?(<NON_TERM>|<TERM>)?)+"]">     /*lista di terminali e non terminali opzionali*/										   								
}

/*----------------------------------------------------------------------------------------REGOLE DI PRODUZIONE*/
Node start() :
{Node start_nptr, grammatica_nptr;}
{
  { System.out.println("<start> ::= <grammatica>;");}
  grammatica_nptr=grammatica() <EOF>
  {
    start_nptr=grammatica_nptr;
    return start_nptr;  }
}

//<grammatica> ::= <regole>;
Node grammatica():
{Node grammatica_nptr, regole_nptr;}
{
  {System.out.println("<grammatica> ::= <regole>;");}
  regole_nptr=regole()
  {
    grammatica_nptr=regole_nptr;
    return grammatica_nptr;  }
}

//<regole> ::= <regola> <regola_queue>;
Node regole():
{Node regole_nptr, regola_nptr, regola_queue_nptr;}
{
  {System.out.println("<regole> ::= <regola> <regola_queue>;");}
  regola_nptr=regola() regola_queue_nptr=regola_queue(regola_nptr)
  {
    regole_nptr=regola_queue_nptr;
    return regole_nptr;  }
}

//<regola_queue> ::= <regole> | eps;
Node regola_queue(Node regola_nptr_inherited):
{Node regola_queue_nptr, regole_nptr;}
{
  {System.out.println("<regola_queue> ::= <regole>;");}
  regole_nptr=regole()
  {
    //-------------------------------------------------------------------------------------------------------GESTIONE REGOLA
    //se la "gestione della regola" non ha comportato modifiche
    //all'albero sintattico allra ci porocede normalmente
    if(regola_nptr_inherited!=null)
   		regola_queue_nptr=new Node(Symbol.REGOLE, "regole", regola_nptr_inherited, regole_nptr);/*conservare questa riga se si vuole eliminare
   																								  la "gestione della regola"*/
   	//altrimenti
   	else
   		//se la "gestione della regola" ha cancellato il nodo di una regola
   		//ma non il nodo delle regole successive allora le regole successive
   		//vengono sostituite alla regola eliminata.
   		if(regole_nptr!=null)
   			regola_queue_nptr=new Node(Symbol.REGOLE, "regole", regole_nptr);
   		
		//se la "gestione della regola" ha cancellato il nodo di una regola
		//e anche quello delle regole successive, allora l'insieme delle regole
		//si annulla.
   		else
   			regola_queue_nptr=null;
   		
   	return regola_queue_nptr;/*conservare questa riga se si vuole eliminare la "gestione della regola"*/
   	//-------------------------------------------------------------------------------------------------------/GESTIONE REGOLA  }
  
| {System.out.println("<regola_queue> ::= eps;");}
  {/*EPSILON*/}
  {
    regola_queue_nptr=regola_nptr_inherited;
    return regola_queue_nptr;  }
}

//<regola> ::= [OP_LOOKAHEAD PARAPERTA_T NUM_LOOKAHEAD PARCHIUSA_T] NON_TERM PUO_ESSERE <corpo> PV;
Node regola():
{Node regola_nptr, corpo_nptr;
 Token OP_LOOKAHEAD_t, NUM_LOOKAHEAD_t, NON_TERM_t;}
{
  {System.out.println("<regola> ::= OP_LOOKAHEAD PARAPERTA_T NUM_LOOKAHEAD PARCHIUSA_T NON_TERM PUO_ESSERE <corpo> PV;");}
  OP_LOOKAHEAD_t=<OP_LOOKAHEAD> <PARAPERTA_T> NUM_LOOKAHEAD_t=<NUM_LOOKAHEAD> <PARCHIUSA_T> NON_TERM_t=<NON_TERM> <PUO_ESSERE> corpo_nptr=corpo() <PV>
  {
    regola_nptr=new Node(Symbol.REGOLA_LLK, "regola_llk", new Node(Symbol.NUM_LOOKAHEAD, NUM_LOOKAHEAD_t.image), new Node(Symbol.NON_TERM, NON_TERM_t.image), corpo_nptr);

	//-------------------------------------------------------------------------------------------------------GESTIONE REGOLA
	//se la regola non è presente in tabella
	//allora la si inserisce e il parsing non subisce alterazioni
	if(!table.contains(NON_TERM_t.image))
		table.put(NON_TERM_t.image, corpo_nptr);
	//se la regola è già presente allora il suo corpo lo si sposta
	//nel corpo della regola già definita
	else{
		//preleviamo il corpo della regola già presente nella tabella
		Node corpo=table.get(NON_TERM_t.image);
	
		//se la regola prelevata dall tabella ha un corpo
		//formato da un solo simbolo terminale o non terminale
		//allora il corpo della regola già definita viene
		//modificato in un corpo contenente una "pipe" di elementi.
		if(corpo.getSon()==null){
			  
			//aggiungiamo, in pipe, il corpo della regola corrente
			//alla regola già definita
			String val=corpo.getVal();
			Symbol sym=corpo.getSymbol();
			corpo.setVal("oppure");
			corpo.setSymbol(Symbol.OPPURE);
			corpo.setSon(new Node(sym, val));
			corpo.getSon().setBrother(corpo_nptr); 
		}
		//altrimenti
		else
			
			//se la regola prelevata dalla tabella ha un corpo
			//formato da "pipe" di terminali e non terminali
			if(corpo.getSon().getBrother()!=null){
		
			  	//puntiamo all'ultimo insieme di elementi in "pipe"
				while(corpo.getSon().getBrother().getVal()=="oppure")
					corpo=corpo.getSon().getBrother();
		
				//aggiungiamo il corpo della regola corrente alla
				//"pipe" (corpo) della regola già definita
				Node elementi=corpo.getSon().getBrother();
				corpo.getSon().setBrother(new Node(Symbol.OPPURE, "oppure", elementi, corpo_nptr));
			}
			//se la regola prelevata dall tabella ha un corpo
			//formato da una sola concatenazione di simboli terminali e non
			//terminali, allora il corpo della regola già definita viene
			//modificato in un corpo contenente una "pipe" di elementi.
			else
			{
			  //aggiungiamo, in pipe, il corpo della regola corrente
			  //alla regola già definita
			  Node elementi=corpo.getSon();
			  corpo.setVal("oppure");
			  corpo.setSymbol(Symbol.OPPURE);
			  corpo.setSon(elementi);
			  corpo.setBrother(corpo_nptr);
			}
		regola_nptr=null;
	}
	//-------------------------------------------------------------------------------------------------------/GESTIONE REGOLA
    return regola_nptr;/*conservare questa riga se si vuole eliminare la "gestione della regola"*/  }
  
| {System.out.println("<regola> ::= NON_TERM PUO_ESSERE <corpo> PV;");}
  NON_TERM_t=<NON_TERM> <PUO_ESSERE> corpo_nptr=corpo() <PV>
  {
    regola_nptr=new Node(Symbol.REGOLA_LL1, "regola_ll1", new Node(Symbol.NON_TERM, NON_TERM_t.image), corpo_nptr);

    //-------------------------------------------------------------------------------------------------------GESTIONE REGOLA
	//se la regola non è presente in tabella
	//allora la si inserisce e il parsing non subisce alterazioni
	if(!table.contains(NON_TERM_t.image))
		table.put(NON_TERM_t.image, corpo_nptr);
	//se la regola è già presente allora il suo corpo lo si sposta
	//nel corpo della regola già definita
	else{
	  //preleviamo il corpo della regola già presente nella tabella
		Node corpo=table.get(NON_TERM_t.image);
	
		//se la regola prelevata dall tabella ha un corpo
		//formato da un solo simbolo terminale o non terminale
		//allora il corpo della regola già definita viene
		//modificato in un corpo contenente una "pipe" di elementi.
		if(corpo.getSon()==null){
			  
			//aggiungiamo, in pipe, il corpo della regola corrente
			//alla regola già definita
			String val=corpo.getVal();
			Symbol sym=corpo.getSymbol();
			corpo.setVal("oppure");
			corpo.setSymbol(Symbol.OPPURE);
			corpo.setSon(new Node(sym, val));
			corpo.getSon().setBrother(corpo_nptr); 
		}
		//altrimenti
		else
			
			//se la regola prelevata dalla tabella ha un corpo
			//formato da "pipe" di terminali e non terminali
			if(corpo.getSon().getBrother()!=null){
		
			  	//puntiamo all'ultimo insieme di elementi in "pipe"
				while(corpo.getSon().getBrother().getVal()=="oppure")
					corpo=corpo.getSon().getBrother();
		
				//aggiungiamo il corpo della regola corrente alla
				//"pipe" (corpo) della regola già definita
				Node elementi=corpo.getSon().getBrother();
				corpo.getSon().setBrother(new Node(Symbol.OPPURE, "oppure", elementi, corpo_nptr));
			}
			//se la regola prelevata dall tabella ha un corpo
			//formato da una sola concatenazione di simboli terminali e non
			//terminali, allora il corpo della regola già definita viene
			//modificato in un corpo contenente una "pipe" di elementi.
			else
			{
			  //aggiungiamo, in pipe, il corpo della regola corrente
			  //alla regola già definita
			  Node elementi=corpo.getSon();
			  corpo.setVal("oppure");
			  corpo.setSymbol(Symbol.OPPURE);
			  corpo.setSon(elementi);
			  corpo.setBrother(corpo_nptr);
			}
	  regola_nptr=null;
	}
	//-------------------------------------------------------------------------------------------------------GESTIONE REGOLA
    return regola_nptr;/*conservare questa riga se si vuole eliminare la "gestione della regola"*/  }
}

//<corpo> ::= <elementi> <elementi_queue>;
Node corpo():
{Node corpo_nptr, elementi_nptr, elementi_queue_nptr;}
{
  {System.out.println("<corpo> ::=  <elementi> <elementi_queue>;");}
  elementi_nptr=elementi() elementi_queue_nptr=elementi_queue(elementi_nptr)
  {
    elementi_nptr=elementi_queue_nptr;
    return elementi_nptr;  }
}

//<elementi_queue> ::= PIPE <corpo> | eps;
Node elementi_queue(Node elementi_nptr_inherited):
{Node elementi_queue_nptr, corpo_nptr;}
{
  {System.out.println("<elementi_queue> ::=  PIPE <corpo>;");}
  <PIPE> corpo_nptr=corpo()
  {
    elementi_queue_nptr=new Node(Symbol.OPPURE, "oppure", elementi_nptr_inherited, corpo_nptr);
    return elementi_queue_nptr;  }
| {System.out.println("<elementi_queue> ::= eps;");}
  {/*EPSILON*/}
  {
    elementi_queue_nptr=elementi_nptr_inherited;
    return elementi_queue_nptr;  }
}

//<elementi> ::= <elemento> <elemento_queue>;
Node elementi():
{Node elementi_nptr, elemento_nptr, elemento_queue_nptr;}
{
  {System.out.println("<elementi> ::=  <elemento> <elemento_queue>;");}
  elemento_nptr=elemento() elemento_queue_nptr=elemento_queue(elemento_nptr)
  {
    elementi_nptr=elemento_queue_nptr;
    return elementi_nptr;  }
}

//<elemento_queue> ::= <elementi> | eps;
Node elemento_queue(Node elemento_nptr_inherited):
{Node elemento_queue_nptr, elementi_nptr;}
{
  {System.out.println("<elemento_queue> ::= <elementi>;");}
  elementi_nptr=elementi()
  {
    elemento_queue_nptr=new Node(Symbol.CONCAT, "concat", elemento_nptr_inherited, elementi_nptr);
    return elemento_queue_nptr;  }
| {System.out.println("<elemento_queue> ::=  eps;");}
  {/*EPSILON*/}
  {
    elemento_queue_nptr=elemento_nptr_inherited;
    return elemento_queue_nptr;  }
}

//<elemento> ::= TERM | NON_TERM | eps | PARAPERTA_Q <elementi> PARCHIUSA_Q;
Node elemento():
{Node elemento_nptr, elementi_nptr;
 Token TERM_t, NON_TERM_t, EPS_t;}
{
  {System.out.println("<elemento> ::=  TERM;");}
  TERM_t=<TERM>
  {
    elemento_nptr=new Node(Symbol.TERM, TERM_t.image);
    return elemento_nptr;  }
| {System.out.println("<elemento> ::=  NON_TERM;");}
  NON_TERM_t=<NON_TERM>
  {
    elemento_nptr=new Node(Symbol.NON_TERM, NON_TERM_t.image);
    return elemento_nptr;  }
| {System.out.println("<elemento> ::=  EPS;");}
  EPS_t=<EPS>
  {
    elemento_nptr=new Node(Symbol.EPS, EPS_t.image);
    return elemento_nptr;  }
| {System.out.println("<elemento> ::= PARAPERTA_Q <elementi> PARCHIUSA_Q;");}
  <PARAPERTA_Q> elementi_nptr=elementi() <PARCHIUSA_Q>
  {
    elemento_nptr=new Node(Symbol.OPZ, "?", elementi_nptr);
    return elemento_nptr;  }
}
